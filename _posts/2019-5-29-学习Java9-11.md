---
layout: post
title: 学习Java9-11
published: false
---

## Java9-11新特性一览
### Java 9
* **模块化**
* Java Shell
* 新的操作系统进程的API
* G1作为默认垃圾收集器
* 加入微基准测试套件JMH
* 支持HTTP2.0和WebSocket
* 支持响应式编程(reactive program)

### Java 10
* 本地变量的类型推导
* JDK的代码库合并
* 垃圾收集接口
* 并行化的G1全垃圾收集器(full GC)
* 应用级别的类数据共享
* Thread-local handshakes(一种可以不通过safepoint就实现单个线程的停止的新机制)
* 移除javah工具
* 支持更多的Unicode语言标记扩展
* 支持非DRAM内存设备
* 加入实验性的基于Java的JIT(just-in-time)编译器
* 加入一些默认的根证书

### Java 11
* 动态的class文件常量
* Epsilon,一个新的低开销的垃圾收集器
* 移除Java EE和CORBRA模块
* 可以在lambda的参数中使用`var`语法

## JDK内部改进
9-11也进行了很多JDK内部的改进,这些修改主要是对JVM内部实现的一些修改和优化,其实和一般的开发人员关系不大.它们都有对应的JEP(JDK Enhancement Proposal),下面是其中一些比较重要的JEP:

### Improved contended locking
Java对多个线程共享的数据的管理做的不错,它为每个对象和类分配一个monitor,这些monitor的锁在任何时候只会被一个线程控制.从本质上说,这些锁就是给予了线程这些对象的monitor.如果有其他线程在等待这个锁的队列中,那么就叫竞争锁.
这个JEP的目的是为了提高JVM管理竞争锁的整体性能,它的提升主要体现在下面三个操作:
* Faster monitor enter
* Faster monitor exit
* Faster notifications

### Segmented code cache
分段的代码缓存.这个改进使得JVM有更快的更高效的运行时.它的核心是把代码缓存分成三块,每一块存储特定类型的编译好的代码,
<div align="center"><img width="796" height="455" src="https://zjjfly.github.io/images/20190529/j911-1.JPG"/></div>
代码缓存区是一个固定大小的区域.默认情况下,其中有3MB是固定存放non-methed代码的,剩余的部分平均分配给profiled和non-profiled代码.用户可以通过JVM参数手动调节.
> -xx:NonMethodCodeHeapSize
> -xx:ProfiledCodeHeapSize
> -xx:NonProfiledCodeHeapSize

### Smart Java compilation
`sjavac`,一个更智能的`javac`,支持增量编译,加快了编译速度,但目前还没有替代`javac`.

### Resolve Lint and Doclint Warnings
之前的JDK编译的时候会由`javac`发出很多lint(字节码和源码检查)和doclint(javadoc检查)告警,这个提案就是为了处理这些告警,至少是核心库的告警.

### Tiered attribution for Javac
`javac`会在编译的时候进行类型推断,之前使用的是一种推断归因工具,这种工具的类型推断结果虽然准确但性能不高,现在使用一种新的叫做分层归因工具替代它,目的还是为了加快编译速度.

### Annotations pipeline 2.0
在Java8中,引入了三个特性：
* lambda表达式
* 重复注解
* 类型注解
  

这三个特性影响了Java注解,但`javac`没有对原有的对注解的处理做修改,而是加入了一些硬编码对这些新的注解进行处理,但这种方式效率不高而且维护麻烦,所以这个改进是为了去掉这些硬编码,重构了处理注解的代码.

### New version-string scheme
新的版本命名格式,原来是使用`8u211`这样的格式,现在使用的是形如`12.0.1`的格式.

### Generating runtime compiler tests automatically
Java支持很多平台,所以要在所有平台上测试运行时编译器(JIT)是一件非常麻烦的事情,现在引入了一个新的工具用于自动生成目标平台的JIT的测试代码.

### Testing class-file attributes generated by javac
之前的JDK中没有方法可以测试`javac`生成的类文件的属性是否正确,现在加入了这方面的工具.

### Storing interned strings in class-data sharing archives
共享类数据(class-data sharing)是Java5的时候引入的新特性.在JVM安装过程中,安装进程会加载一系列核心JVM类(比如 rt.jar)到一个共享的内存映射区域.CDS减少了加载这些类需要的时间,提高了JVM启动的速度,允许这些类被不同的JVM实例共享,同时也减少了内存消耗.但在9之前的实现还是不够高效,并且只支持Boot ClassLoader加载的类,9和11分别对这两个问题进行了处理.

### Compact strings
紧凑字符串.之前的字符串的底层使用的是`char[]`存储.一个char要占16bits,但实际开发过程占,使用最多的是`Latin-1`字符,它们只需占用8bits或者说1byte.现在内部使用`byte[]`来存储,节约了内存空间.

### Merging selected Xerces 2.11.0 updates into JAXP
把Xerces2.11.0(一个Java的XML处理库)的部分更新合入JAXP(Java的处理XML的API).

### Unicode 8.0.0
支持Unicode8.0.0标准

### Reserved stack areas for critical sections
为关键代码区域加上保留的线程栈空间,以此来减少发生`StackOverflowError`,的可能性.如果当前执行的方法的栈空间不够了,但这个方法有注解`jdk.internal.vm.annotation.ReservedStackAccess`,那么就会分配一段临时的栈空间让方法继续执行.当然,如果需要的额外空间很大,最终还是会抛出`StackOverflowError`.

### Additional tests for humongous objects in G1
为了测试G1垃圾收集器对于大对象的处理,添加新的白盒测试方法.G1收集器会把堆内存分成很多小的区域,所谓大对象就是指那些内存占用大于一个分区的单个对象.

### Improving test-failure troubleshooting
Java会自动收集信息以方便测试未通过的问题定位,包括两类信息:
* 进程
    * C代码栈
    * Core dumps
    * Mini dumps
    * 堆统计信息
    * Java代码栈
* 测试环境
  * CPU负载
  * 内存空间
  * 磁盘空间
  * I/O负载
  * 打开文件
  * 打开的套接字(socket)
  * 正在运行的进程
  * 系统事件
  * 系统消息
### Optimizing string concatenation
之前,`javac`会把`"hello,"+"world"`这样的代码在编译的时候转换成调用`StringBuiler::append`方法.现在,`javac`生成的字节码变成了使用`invokedynamic`指令,以后对字符串拼接的优化不再需要改动编译器生成的字节码,因为不再和具体的实现绑定了.

### HotSpot C++ unit-test framework
HotSpot JVM是用C++写的,这个改进是为了方便开发人员为JVM编写单元测试.

### New HotSpot build system
以前的JDK的构建系统充斥着重复的和无用的代码,这个改进的目标是去除这些代码,并进行简化,提高构建代码的可维护性,并支持未来的不断改进.

### Consolidating the JDF forest into a single repository
Java9由8个不同的代码库组成,如下图:
<div align="center"><img width="900" height="570" src="https://zjjfly.github.io/images/20190529/j911-2.png"/></div>
到了Java10,这几个仓库合成了一个,这样使得开发,维护和更新更简单.


## Java11基础
### Variable handlers
随着Java中的并发和并行编程的不断扩大,我们经常会需要对某个类的字段进行原子或有序操作,但是JVM对Java开发者所开放的权限非常有限.例如:如果要原子性地增加某个字段的值,到目前为止我们可以使用下面三种方式:
* 使用`AtomicInteger`来达到这种效果,这种间接管理方式增加了空间开销,还会导致额外的并发问题
* 使用原子性的`FieldUpdaters`,由于利用了反射机制,操作开销也会更大
* 使用`sun.misc.Unsafe`提供的JVM内置函数API,虽然这种方式比较快,但它会损害安全性和可移植性,当然在实际开发中也很少会这么做.
  

`VarHandle`的出现替代了`java.util.concurrent.atomic`和`sun.misc.Unsafe`的部分操作.并且提供了一系列标准的内存屏障操作,用于更加细粒度的控制内存排序,在安全性,可用性和性能上都要优于现有的API.
这些操作主要是：
* 访问/修改对象成员
* 访问/修改数组元素

### Import statement depreciation warnings
以前,如果代码中导入了被`@Deprecated`标注的类或方法,编译的时候会有警告.现在,编译器在下列的情况下不会产生过时告警:
* 使用`@Deprecated`标注类或方法
* 使用`@SuppressWarnings`标注类或方法
* 产生告警的代码和声明在父类中
* 只用`import`导入过时的类,但没有在其他任何地方使用

### Milling Project Coin
Project Coin是Java7的时候的引入的,它包括下面几个特性:
* `swtich`支持String类型
* 二进制整形字面量
* 数字字面量支持下划线
* `catch`可以一次捕获多种异常
* 简化泛型类的实例化
* `try-with-resource`表达式
* 改进对不定参数方法的调用

Java9中,对其进行了五个方面的改进:
* `@SafeVarargs`可以加在private方法上
* try-with-resource中不再必须声明新的对象,可以传入已经声明的的`final`或等价于`final`的对象
* 不再支持使用下划线`_`作为变量名
* 接口支持有具体实现的私有方法

### Inferring type of local variables 
Java10对局部变量的声明进行了简化,不再需要显示的写明类型,可以使用标识符`var`,编译器可以自动推断出它的类型.但这种用法也有一些限制:
* 不能在没有初始化的声明中使用
* 不能在同时声明多个变量的时候使用
* 不能用于数组字面量
* 不能用于元表达式,如lambda和方法引用

`var`可以在for循环中使用:

```java
var numbers = List.of("a", "b", "c");
for (var nr : numbers) {
    System.out.print(nr + " ");
}
```
`var`还可以在lambda表达式中使用,但要使用的话必须加在所有的形参上:
```java
var numbers = new ArrayList<>() {{
    add("a");
    add("bc");
    add("d");
}};
numbers.sort((var s1, var s2) -> s1.length() - s2.length());
```

### Thread-local handshakes

Java10加入的对多线程的改进,使得JVM可以不需要进行全局的暂停就可以停止单个线程,这可以提高偏向锁撤销的速度,降低总体VM延迟,提供更安全的stack trace,减少内存屏障的使用.要启用这个特性,需要JVM参数:

> XX:ThreadLocalHandshakes

### Heap allocation on alternative memory devices

Java10对非DRAM的内存设备提供了支持,要启用需要JVM参数:

> XX:AllocateHeapAt=file-system path

## 模块化
### 什么是模块化
模块是包含代码的可识别工件,使用了元数据来描述模块及其与其他模块的关系.
应用模块化的好处:
* 可以在小型设备上运行
* 可以减小应用的大小
* 应用的性能会更好
* 更容易测试和debug
* 维护更容易

为什么Java要引入模块化?
* JDK太大了,对一些小型设备的支持很困难,甚至不可能
* 因为超大的JDK,Java应用很难进行真正的优化
* JRE太大了以至于不能有效的测试和维护Java应用
* JAR文件太大了,这也让支持小型设备成了问题
* 因为JDK和JRE包罗万象,安全是重要的关注点.比如一些不会被应用使用的内部API,由于`public`访问修饰符,还是可以被访问到,这显然是不安全的.模块化有助于解决这个问题

模块必须遵循以下三个核心原则:
* 强封装性.一个模块必须对其他模块隐藏其部分代码,这样用户就不能使用这些被封装的代码,库的作者就可以在不影响用户使用的情况下自由地对封装代码进行更改.
* 定义良好的接口.未封装代码中任何一个重大更改都可能会破坏依赖该代码的其他模块.因此,模块应该向其他模块公开定义良好且稳定的接口.
* 显式依赖.一个模块通常需要使用其他模块来完成自己的工作,这些依赖关系必须是模块定义的一部分,以便模块能够独立运行.

### Java9的模块
Java9的模块化有两个目标:
* 对JDK本身进行模块化
* 提供一个应用程序可以使用的模块系统

它们是密切相关的,JDK的模块化可通过使用与应用程序开发人员使用的相同的模块系统来实现.通过引入模块化系统,使得Java真正的获得了对模块的三个核心原则的支持.
它带来的最重要的几个好处是:
* 可靠的配置.模块系统在编译和运行之前会检查给定的模块组合是否满足所有依赖关系,从而导致更少的运行时错误(如因为多个版本的JAR都处于classpath中导致的`NoSuchMethodError`或`NoClassDefFoundError`错误).
* 强封装型.模块显示的声明了向外部公开的内容,未公开的内容是无法被外部访问的,这防止了来自其他模块的对其内部实现细节的依赖.
* 可扩展性.显式边界能够让开发团队并行工作,同时可创建可维护的代码库.
* 安全性.在JVM的最深层次上执行强封装,从而减少Java运行时的攻击面,同时无险获得对敏感内部类的反射访问(Java是可以通过反射修改类的private成员的).

JDK把代码划分成了很多个模块,每个模块都清晰的定义了暴露的内容以及依赖的模块.下面是Java9的模块关系图:
<div align="center"><img width="900" height="462" src="https://zjjfly.github.io/images/20190529/j911-3.jpg"/></div>
### 定义模块
模块拥有一个名称,并对相关的代码以及可能的其他资源拥进行分组,同时使用一个模块描述符进行描述.模块描述符保存在一个名为`module-info.java`的文件中.下面是`java.prefs`模块的`module-info.java`:
```java
module java.prefs {
    requires java.xml;

    exports java.util.prefs;

    uses java.util.prefs.PreferencesFactory;
}
```
模块描述的开头是关键字`module`,后面跟着一个模块的名称.由于模块都位于一个全局命名空间中,因此模块名称必须是唯一的.与包名称一样,可以使用反向DNS符号(例如com.mycompany.project.somemodule)等约定来确保模块的唯一性.
模块描述的主体是有三行,其中`requires`声明了对另一个模块的依赖.`exports`是一个导出声明,告知了别的模块它们可以访问这个包,没有export的包是无法被别的模块访问的.最后一行的意思是声明这个模块是服务`java.util.prefs.PreferencesFactory`的消费者.
下面列出了模块描述体中所有支持的语法:
* `requires module.name`:表示本模块对一个模块的依赖,如果缺少这个模块则会无法编译和运行.
* `requires transitive module.name`:和`requires`基本一样,额外说明这个依赖是传递的,依赖本模块的其他模块会自动继承对这一依赖.当只需要其他模块供内部使用时,使用requires就足够了.但另一方面,如果需要在导出类型中使用另一个模块中的类型,那么就要使用`requires transitive`.
* `requires static module.name`:表示在编译的时候对这个模块是强依赖,但在运行时这个依赖是可选的.
* `exports pkg.name`:表示导出这个包,依赖这个模块的其他模块可以访问这个包.
* `exports pkg.name to module.name`:表示导出这个包给特定模块.可以使用逗号作为分隔符限定导出给多个模块.
* `opens pkg.name`:表示公开这个包,其他模块可以使用反射访问这个包中的类的私有成员.
* `opens pkg.name to module.name`:表示公开这个包给特定模块.同样可以指定对多个模块公开.
* `uses service.class.name`:它用于声明对一个服务接口的依赖.如果其他模块有通过`provides`声明实现这个服务接口,那么这个模块就可以通过`java.util.ServiceLoader`消费这些实现(如果实现就在同一个包中,也可以被消费).
* `provides service.class.name with service.class.impl.name`:表示为某个服务接口提供实现类.同样可以提供多个实现类.

上面这些不同的语法提供了不同的可访问性.可见性包括两个方面:编译时可访问性和反射可访问性.下面是反映这些可访问性规则的表:
<div align="center"><img width="795" height="277" src="https://zjjfly.github.io/images/20190529/j911-4.png"/></div>

## JShell

JShell是Java9加入的一个交互式的REPL(Read-Eval-Print Loop)工具,它可以对Java的声明,表达式进行求值,而且和一般的Java代码不一样,不需要它们处于一个方法中.而且它还有下面的几个便利的特性:

* tab键补全
* 自动补全声明尾部的分号
* 自动import需要的包
* 自动补全定义(为未绑定变量的表达式分配变量名)

JShell的语法如下:

> jshell  \<options\> \<load files\>

具体用法可以使用`jshell -h`查看.要退出JShell,可以输入`/ex`或`/exit`.除此之外,JShell中还可以输入其他一些命令,可以在JShell中输入`/?`或`/help`来查看.

JShell的主要作用是执行一些简短的实验性质的代码,或者作为Java脚本(一般以`.jsh`结尾)的执行器.

## Process API
Java9中加入了两个新的进程相关的接口:`ProcessHandle`和`ProcessHandle.Info`.一个`ProcessHandle`标识了一个操作系统进程并提供了管理进程的方法.`Info`存储了进程相关的信息.这两个接口的引入解决了下面几个问题.
### 判断进程是否存活
在之前版本的Java中,只有通过进程的PID去标识一个进程,这种方法的问题是:PID是可以重用的.
对于桌面和服务器操作系统,它们会尽量的不重用PID,但对于一些嵌入式系统,PID是一个16位的数字,所以很容易发生重用.但有了`ProcessHandle`,使用它的`isAlive()`方法就可以避免这个问题.
### 获取进程PID
获取进程的PID在实际编程中是很有用的,在之前,Java的`Process`类没有任何方法可以获取PID.而现在,可以调用`toHandle()`方法把`Process`对象转换成`ProcessHandle`对象,然后调用`pid()`方法就可以得到进程PID.
如果需要得到当前进程的PID,可以调用`ProcessHandle.current().pid()`.
### 获取进程信息
`ProcessHandle`对象调用`info()`方法可以得到一个`ProcessHandle.Info`对象,通过它可以获取下面的信息:
* `command()`方法返回`Optional<String>`,包含了启动进程的命令.
* `arguments()`方法返回`Optional<String[]>`,包含启动进程的命令的参数.
* `commandLine()`返回`Optional<String>`,包含了启动进程的命令和参数.
* `startInstant()`返回`Optional<Instant>`,包含了进程的起始时间.
* `totalCpuDuration()`返回`Optional<Duration>`,包含了进程从开始起占用的CPU时间.
* `user()`返回`Optional<String>`,包含了进程的所有者的名字.
为什么返回的类型都是`Optional`?因为无法保证操作系统或Java的实现可以返回这些信息.但对于大多数操作系统来说,这些信息都是可以获得的.
### 列出进程
`ProcessHandle`提供了方法用于列出进程,包括:
* 列出进程的所有子进程,使用`children()`实例方法.
* 列出进程的所有后代进程,使用`descendants()`实例方法.
* 列出系统的所有进程,使用`allProcesses()`静态方法.

这些方法返回的都是`Stream<ProcessHandle>`.要注意,这些方法只返回在调用的时候存活的进程,但不保证在遍历返回结果的时候这些进程仍然存活.

### 等待进程结束
之前Java等待进程结束,需要使用使用循环来定期调用`isAlive()`方法.`ProcessHandle`提供了`onExit()`方法来更优雅的完成这一任务.它返回的类型是`CompletableFuture<ProcessHandle>`(`CompletableFuture`是Java8加入的异步API),你可以通过`handle.onExit().join()`来等待进程结束.你可以多次调用`onExit()`,每次返回的都是不同的`CompletableFuture`对象,它们都和相同的进程关联.
