---
layout: post
title: 学习Java9-11
published: true
---

## Java9-11新特性一览
### Java 9
* **模块化**
* Java Shell
* 新的操作系统进程的API
* G1作为默认垃圾收集器
* 加入微基准测试套件JMH
* 支持HTTP2.0和WebSocket
* 支持响应式编程(reactive program)

### Java 10
* 本地变量的类型推导
* JDK的代码库合并
* 垃圾收集接口
* 并行化的G1全垃圾收集器(full GC)
* 应用级别的类数据共享
* Thread-local handshakes(一种可以不通过safepoint就实现单个线程的停止的新机制)
* 移除javah工具
* 支持更多的Unicode语言标记扩展
* 支持非DRAM内存设备
* 加入实验性的基于Java的JIT(just-in-time)编译器
* 加入一些默认的根证书

### Java 11
* 动态的class文件常量
* Epsilon,一个新的低开销的垃圾收集器
* 移除Java EE和CORBRA模块
* 可以在lambda的参数中使用`var`语法

## JDK内部改进
9-11也进行了很多JDK内部的改进,这些修改主要是对JVM内部实现的一些修改和优化,其实和一般的开发人员关系不大.它们都有对应的JEP(JDK Enhancement Proposal),下面是其中一些比较重要的JEP:

### Improved contended locking
Java对多个线程共享的数据的管理做的不错,它为每个对象和类分配一个monitor,这些monitor的锁在任何时候只会被一个线程控制.从本质上说,这些锁就是给予了线程这些对象的monitor.如果有其他线程在等待这个锁的队列中,那么就叫竞争锁.
这个JEP的目的是为了提高JVM管理竞争锁的整体性能,它的提升主要体现在下面三个操作:
* Faster monitor enter
* Faster monitor exit
* Faster notifications

### Segmented code cache
分段的代码缓存.这个改进使得JVM有更快的更高效的运行时.它的核心是把代码缓存分成三块,每一块存储特定类型的编译好的代码,
<div align="center"><img width="796" height="455" src="https://zjjfly.github.io/images/20190529/j911-1.JPG"/></div>
代码缓存区是一个固定大小的区域.默认情况下,其中有3MB是固定存放non-methed代码的,剩余的部分平均分配给profiled和non-profiled代码.用户可以通过JVM参数手动调节.
> -xx:NonMethodCodeHeapSize
> -xx:ProfiledCodeHeapSize
> -xx:NonProfiledCodeHeapSize

### Smart Java compilation
`sjavac`,一个更智能的`javac`,支持增量编译,加快了编译速度,但目前还没有替代`javac`.

### Resolve Lint and Doclint Warnings
之前的JDK编译的时候会由`javac`发出很多lint(字节码和源码检查)和doclint(javadoc检查)告警,这个提案就是为了处理这些告警,至少是核心库的告警.

### Tiered attribution for Javac
`javac`会在编译的时候进行类型推断,之前使用的是一种推断归因工具,这种工具的类型推断结果虽然准确但性能不高,现在使用一种新的叫做分层归因工具替代它,目的还是为了加快编译速度.

### Annotations pipeline 2.0
在Java8中,引入了三个特性：
* lambda表达式
* 重复注解
* 类型注解
  

这三个特性影响了Java注解,但`javac`没有对原有的对注解的处理做修改,而是加入了一些硬编码对这些新的注解进行处理,但这种方式效率不高而且维护麻烦,所以这个改进是为了去掉这些硬编码,重构了处理注解的代码.

### New version-string scheme
新的版本命名格式,原来是使用`8u211`这样的格式,现在使用的是形如`12.0.1`的格式.

### Generating runtime compiler tests automatically
Java支持很多平台,所以要在所有平台上测试运行时编译器(JIT)是一件非常麻烦的事情,现在引入了一个新的工具用于自动生成目标平台的JIT的测试代码.

### Testing class-file attributes generated by javac
之前的JDK中没有方法可以测试`javac`生成的类文件的属性是否正确,现在加入了这方面的工具.

### Storing interned strings in class-data sharing archives
共享类数据(class-data sharing)是Java5的时候引入的新特性.在JVM安装过程中,安装进程会加载一系列核心JVM类(比如 rt.jar)到一个共享的内存映射区域.CDS减少了加载这些类需要的时间,提高了JVM启动的速度,允许这些类被不同的JVM实例共享,同时也减少了内存消耗.但在9之前的实现还是不够高效,并且只支持Boot ClassLoader加载的类,9和11分别对这两个问题进行了处理.

### Compact strings
紧凑字符串.之前的字符串的底层使用的是`char[]`存储.一个char要占16bits,但实际开发过程占,使用最多的是`Latin-1`字符,它们只需占用8bits或者说1byte.现在内部使用`byte[]`来存储,节约了内存空间.

### Merging selected Xerces 2.11.0 updates into JAXP
把Xerces2.11.0(一个Java的XML处理库)的部分更新合入JAXP(Java的处理XML的API).

### Unicode 8.0.0
支持Unicode8.0.0标准

### Reserved stack areas for critical sections
为关键代码区域加上保留的线程栈空间,以此来减少发生`StackOverflowError`,的可能性.如果当前执行的方法的栈空间不够了,但这个方法有注解`jdk.internal.vm.annotation.ReservedStackAccess`,那么就会分配一段临时的栈空间让方法继续执行.当然,如果需要的额外空间很大,最终还是会抛出`StackOverflowError`.

### Additional tests for humongous objects in G1
为了测试G1垃圾收集器对于大对象的处理,添加新的白盒测试方法.G1收集器会把堆内存分成很多小的区域,所谓大对象就是指那些内存占用大于一个分区的单个对象.

### Improving test-failure troubleshooting
Java会自动收集信息以方便测试未通过的问题定位,包括两类信息:
* 进程
    * C代码栈
    * Core dumps
    * Mini dumps
    * 堆统计信息
    * Java代码栈
* 测试环境
  * CPU负载
  * 内存空间
  * 磁盘空间
  * I/O负载
  * 打开文件
  * 打开的套接字(socket)
  * 正在运行的进程
  * 系统事件
  * 系统消息
### Optimizing string concatenation
之前,`javac`会把`"hello,"+"world"`这样的代码在编译的时候转换成调用`StringBuiler::append`方法.现在,`javac`生成的字节码变成了使用`invokedynamic`指令,以后对字符串拼接的优化不再需要改动编译器生成的字节码,因为不再和具体的实现绑定了.

### HotSpot C++ unit-test framework
HotSpot JVM是用C++写的,这个改进是为了方便开发人员为JVM编写单元测试.

### New HotSpot build system
以前的JDK的构建系统充斥着重复的和无用的代码,这个改进的目标是去除这些代码,并进行简化,提高构建代码的可维护性,并支持未来的不断改进.

### Consolidating the JDF forest into a single repository
Java9由8个不同的代码库组成,如下图:
<div align="center"><img width="900" height="570" src="https://zjjfly.github.io/images/20190529/j911-2.png"/></div>
到了Java10,这几个仓库合成了一个,这样使得开发,维护和更新更简单.


## Java11基础
### Variable handlers
随着Java中的并发和并行编程的不断扩大,我们经常会需要对某个类的字段进行原子或有序操作,但是JVM对Java开发者所开放的权限非常有限.例如:如果要原子性地增加某个字段的值,到目前为止我们可以使用下面三种方式:
* 使用`AtomicInteger`来达到这种效果,这种间接管理方式增加了空间开销,还会导致额外的并发问题
* 使用原子性的`FieldUpdaters`,由于利用了反射机制,操作开销也会更大
* 使用`sun.misc.Unsafe`提供的JVM内置函数API,虽然这种方式比较快,但它会损害安全性和可移植性,当然在实际开发中也很少会这么做.
  

`VarHandle`的出现替代了`java.util.concurrent.atomic`和`sun.misc.Unsafe`的部分操作.并且提供了一系列标准的内存屏障操作,用于更加细粒度的控制内存排序,在安全性,可用性和性能上都要优于现有的API.
这些操作主要是：
* 访问/修改对象成员
* 访问/修改数组元素

### Import statement depreciation warnings
以前,如果代码中导入了被`@Deprecated`标注的类或方法,编译的时候会有警告.现在,编译器在下列的情况下不会产生过时告警:
* 使用`@Deprecated`标注类或方法
* 使用`@SuppressWarnings`标注类或方法
* 产生告警的代码和声明在父类中
* 只用`import`导入过时的类,但没有在其他任何地方使用

### Milling Project Coin
Project Coin是Java7的时候的引入的,它包括下面几个特性:
* `swtich`支持String类型
* 二进制整形字面量
* 数字字面量支持下划线
* `catch`可以一次捕获多种异常
* 简化泛型类的实例化
* `try-with-resource`表达式
* 改进对不定参数方法的调用

Java9中,对其进行了五个方面的改进:
* `@SafeVarargs`可以加在private方法上
* try-with-resource中不再必须声明新的对象,可以传入已经声明的的`final`或等价于`final`的对象
* 不再支持使用下划线`_`作为变量名
* 接口支持有具体实现的私有方法

### Inferring type of local variables 
Java10对局部变量的声明进行了简化,不再需要显示的写明类型,可以使用标识符`var`,编译器可以自动推断出它的类型.但这种用法也有一些限制:
* 不能在没有初始化的声明中使用
* 不能在同时声明多个变量的时候使用
* 不能用于数组字面量
* 不能用于元表达式,如lambda和方法引用 

`var`可以在for循环中使用:

```java
var numbers = List.of("a", "b", "c");
for (var nr : numbers) {
    System.out.print(nr + " ");
}
```
`var`还可以在lambda表达式中使用,但要使用的话必须加在所有的形参上:
```java
var numbers = new ArrayList<>() {{
    add("a");
    add("bc");
    add("d");
}};
numbers.sort((var s1, var s2) -> s1.length() - s2.length());
```

###  Thread-local handshakes

Java10加入的对多线程的改进,使得JVM可以不需要进行全局的暂停就可以停止单个线程,这可以提高偏向锁撤销的速度,降低总体VM延迟,提供更安全的stack trace,减少内存屏障的使用.要启用这个特性,需要JVM参数:

> XX:ThreadLocalHandshakes

###  Heap allocation on alternative memory devices

Java10对非DRAM的内存设备提供了支持,要启用需要JVM参数:

> XX:AllocateHeapAt=<file system path>

## 模块化

