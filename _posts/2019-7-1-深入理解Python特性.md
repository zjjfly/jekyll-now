---
layout: post
title: Python Tricks笔记
published: false
---

什么是Python Tricks?就是一小段Python代码,它既传授了Python语言的一个特性,也是一个让你深入发掘这一特性的驱动力.

## 写出更简洁的Python

### 善用assert

有的时候一个很有用的语言特性会得不到特别多的关注,Python的`assert`就是一个例子.它是一个dubug的帮手,可以测试一个条件表达式.如果表达式的结果为真,什么事都不会发生;如果表达式为假,程序会抛出一个`AssertionError`的异常.

#### 一个assert的例子

来看一个计算商品打折后的价格的例子:

```python
def apply_discount(product, discount):
    price = int(product['price'] * (1.0 - discount))
    assert 0 < price < product['price']
    return price
```

这段代码中的`assert`保证了打折后的价格不会低于0,也不会高于商品的原来的价格.使用代码测试一下.

```python
shoes = {'name': 'Fancy Shoes', 'price': 14900}
apply_discount(shoe,0.25)
```

最后的输出是`11175`,符合预期.再故意使用一个错误的折扣来测试.

```python
apply_discount(shoe,2.0)
```

程序会报错:

```
Traceback (most recent call last):
  File "D:/WorkSpace/PythonTricks/ch2/assert.py", line 10, in <module>
    apply_discount(shoes, 2.0)
  File "D:/WorkSpace/PythonTricks/ch2/assert.py", line 3, in apply_discount
    assert 0 < price < product['price']
AssertionError
```

使用`assert`的好处是可以更快速的debug,而且从长远来看它会让你的代码更容易维护.

#### 为什么不使用一般的异常

为什么不使用`if-else`并抛出一个一般的异常呢?因为`assert`告知开发人员出现了不可恢复的错误,而不是那些可以预估到的错误,如文件不存在这样的错误.

`assert`用于程序内部的自省,它断言一些条件是不可能的,如果这些条件有一个不满足,那就说明你的代码是有bug的,你就可以很快的通过报错信息来定位出错的代码.这条准则同样适用于其他语言.但记住,**断言错误永远不应该出现,除非你的程序有bug**.

#### assert的语法

根据Python的文档,`assert`语法是这样的:

> assert_stmt ::= "assert" expression1 ["," expression2]

其中`expression`是一个条件表达式,`expression2`是可选的自定义错误信息.

Python解释器会把`assert`表达式转换成下面的代码:

```python
if __debug__:
	if not expression1:
		raise AssertionError(expression2)
```

可以看出,全局变量`__debug__`决定了`assert`是否起作用,一般情况下这个变量都是`True`的.

#### assert的陷阱

1.不要把`assert`用于数据验证.因为`assert`可以通过命令行参数`-O`和`-OO`,或是环境变量`PYTHONOPTIMIZE`来禁用.如果你的代码使用`assert`来检查方法的参数是否包含错误的或不符合预期的参数,那么就会产生bug或安全漏洞.

举个例子,你写了一个删除商品的方法:

```python
def delete_product(prod_id, user):
	assert user.is_admin(), 'Must be admin'
	assert store.has_product(prod_id), 'Unknown product'
	store.get_product(prod_id).delete()
```

当`assert`禁用时,会出现两个问题:

* 任何用户都可以删除商品
* 黑客可以通过DDOS来攻击,导致服务器宕机

怎么解决这个问题,那就是不用`assert`来验证,而是用一般的`if`表达式并在必要的时候抛出验证错误.就像这样:

```python
def delete_product(product_id, user):
	if not user.is_admin():
		raise AuthError('Must be admin to delete')
	if not store.has_product(product_id):
		raise ValueError('Unknown product id')
	store.get_product(product_id).delete()
```

这样写的还有一个好处是,相比断言错误,这里抛出的自定义的异常在语义上更加正确.

2.永远不会失败的断言.如果你不小心在`assert`表达式中加了括号,那么这个断言就永远是`True`的.例子:

```python
assert(1 == 2, 'This should fail')
```

原因是实际上这里的条件表达式变为了一个tuple,而tuple作为一个条件表达式永远是`True`的.这种写法在Python3中会导致一个语法告警,所以不再那么容易出现了.

### 充足的逗号

当你在dict,list和set常量中添加删除元素的时候,建议你在每一个行的末尾都加上逗号.

你可能一下子不明白我在说啥?看一个例子,假设你的代码中有下面这样的一个list:

```python
names = ['Alice', 'Bob', 'Dilbert']
```

如果你修改了其中一个元素,那么在版本控制系统中很难看出你改的内容,特别是当这个list的元素比较多的时候,因为版本控制系统如Git都是基于行的.

一种更好的代码风格是这样的:

```python
names = [
	'Alice',
	'Bob',
	'Dilbert'
]
```

每个元素一行,这样在版本控制系统中看代码的diff的时候很容易就知道加了新增,删除或修改了哪些元素.

但这样写还有一个问题,就是当你新增或删除元素的时候,需要手动的修改逗号的位置,比如在这个list后面再加一个元素,你需要在`'Dilbert'`后加一个逗号.这样很容易因为忘记修改逗号导致bug.比如:

```python
names = [
	'Alice',
	'Bob',
	'Dilbert' # 漏加了一个逗号
    'Jane'
]
```

这个list的打印结果是:

> ['Alice', 'Bob', 'DilbertJane']

Python把最后两行的字符串合并成了一个字符串.这被称为`字符串字面量拼接`.这是文档中明确说明的一种行为.它在有些情况下很管用,但也容易引起问题.

回到上面的代码,要解决这个bug只要加上缺失的逗号就行了,但这样每加一个元素都需要改两行代码显然是件麻烦的事情.解决的办法就是在每一个元素后都加逗号,包括最后一个元素,这种写法在Python中是合法的.

所以`names`这个list最好的写法是这样的：

```python
names = [
	'Alice',
	'Bob',
	'Dilbert',
]
```

### 上下文管理器和`with`表达式
